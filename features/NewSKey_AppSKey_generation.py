from Crypto.Cipher import AES
from uplink_packet_handling.processing.device_registry import get_app_key, get_appnonce_netid_devnonce

#need to genrate NEWSKEY AND APPSKEY
#Need to sotre them in teh device yaml file so they can be extracted accordign to teh deviec ADdress
def generate_session_keys(dev_eui: str, config_path="config/network_server_device_config.yaml") -> tuple[bytes, bytes]:
    """
    Derives both NwkSKey and AppSKey for a device by looking up its AppKey using DevEUI.

    Args:
        dev_eui: DevEUI of the device as a hex string (e.g., "0102030405060708")
        app_nonce: 3-byte AppNonce generated by server
        net_id: 3-byte NetID
        dev_nonce: 2-byte DevNonce from device
        config_path: YAML path containing the device registry

    Returns:
        (NwkSKey, AppSKey) as 16-byte AES keys
    """
    #Function to get the App_key that corresponds to teh device_eui
    app_key=get_app_key(dev_eui,config_path)
    app_nonce, net_id, dev_nonce =get_appnonce_netid_devnonce(dev_eui)
    # Validate input lengths
    if not (len(app_key) == 16 and len(app_nonce) == 3 and len(net_id) == 3 and len(dev_nonce) == 2):
        raise ValueError("❌ Invalid input lengths: AppKey(16), AppNonce(3), NetID(3), DevNonce(2)")

    def derive_key(key_type: int) -> bytes:
        block = bytes([key_type]) + app_nonce + net_id + dev_nonce + bytes(7)
        cipher = AES.new(app_key, AES.MODE_ECB)
        return cipher.encrypt(block)

    nwk_skey = derive_key(0x01)
    app_skey = derive_key(0x02)

    print(f"✅ Derived keys for DevEUI {dev_eui}")
    return nwk_skey, app_skey

